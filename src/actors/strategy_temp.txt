    // âš¡ PHASE 3: Circuit Breaker Methods

    /// Handle API error - increment counter and pause trading if threshold reached
    fn handle_api_error(&mut self) {
        self.api_error_count += 1;
        self.last_api_error_time = Some(Instant::now());

        const MAX_API_ERRORS: u32 = 3;
        
        if self.api_error_count >= MAX_API_ERRORS {
            error!(
                "ðŸ”´ CIRCUIT BREAKER TRIGGERED: {} consecutive API errors",
                self.api_error_count
            );
            error!("â¸ï¸  Trading PAUSED for 60 seconds to prevent cascading failures");
            self.is_paused = true;
        } else {
            warn!(
                "âš ï¸  API Error #{}/{} - Trading continues",
                self.api_error_count, MAX_API_ERRORS
            );
        }
    }

    /// Reset error counter on successful API call
    fn reset_api_errors(&mut self) {
        if self.api_error_count > 0 {
            debug!("âœ… API call successful - resetting error counter");
            self.api_error_count = 0;
            self.last_api_error_time = None;
        }
    }

   /// Check if pause should be lifted (60s elapsed since last error)
    fn check_pause_status(&mut self) {
        if !self.is_paused {
            return;
        }

        const PAUSE_DURATION_SECS: u64 = 60;

        if let Some(last_error) = self.last_api_error_time {
            let elapsed = last_error.elapsed().as_secs();
            
            if elapsed >= PAUSE_DURATION_SECS {
                info!("âœ… CIRCUIT BREAKER: 60s elapsed, RESUMING trading");
                self.is_paused = false;
                self.api_error_count = 0;
                self.last_api_error_time = None;
            } else {
                let remaining = PAUSE_DURATION_SECS - elapsed;
                debug!("â¸ï¸  Still paused - {}s remaining", remaining);
            }
        }
    }

    /// Record a losing trade for dynamic blacklist
    fn record_loss(&mut self, symbol: &str) {
        *self.symbol_consecutive_losses.entry(symbol.to_string()).or_insert(0) += 1;
        
        const MAX_CONSECUTIVE_LOSSES: u32 = 2;
        let losses = self.symbol_consecutive_losses[symbol];

        if losses >= MAX_CONSECUTIVE_LOSSES {
            warn!(
                "âš ï¸  TEMP BLACKLIST: {} ({} consecutive losses) - paused for 2 hours",
                symbol, losses
            );
            self.temp_blacklist.insert(symbol.to_string(), Instant::now());
        }
    }

    /// Reset loss counter on winning trade
    fn reset_losses(&mut self, symbol: &str) {
        if self.symbol_consecutive_losses.contains_key(symbol) {
            debug!("âœ… Win! Resetting loss counter for {}", symbol);
            self.symbol_consecutive_losses.remove(symbol);
        }
    }

    /// Check if symbol is temporarily blacklisted
    fn is_temp_blacklisted(&self, symbol: &str) -> bool {
        const BLACKLIST_DURATION_HOURS: u64 = 2;

        if let Some(blacklisted_at) = self.temp_blacklist.get(symbol) {
            let elapsed_secs = blacklisted_at.elapsed().as_secs();
            let is_still_blacklisted = elapsed_secs < (BLACKLIST_DURATION_HOURS * 3600);
            
            if is_still_blacklisted {
                let remaining_hours = (BLACKLIST_DURATION_HOURS * 3600 - elapsed_secs) / 3600;
                debug!("ðŸš« {} is blacklisted ({} hours remaining)", symbol, remaining_hours);
            }
            
            is_still_blacklisted
        } else {
            false
        }
    }
